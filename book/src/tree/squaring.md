# ダブリング

\\( V \\)個の頂点からなる根つき木を考える。すべての子はただ1つの親を持つので、`i`番目の頂点の親を`P[i]`とかくことができる。ただし根の親を根と定義する。`P`は1次元配列なので、ダブリングにより高々対数時間で祖先をたどることができる。

## 最小共通祖先（LCA）

次のアルゴリズムにより、任意の2つの頂点`i`と`j`ついて最小共通祖先を求めることができる。`i`の\\(2^k\\)番目の祖先を`A[i][k]`とかくことにする。また、木の高さを\\( H \\)とおく。

1. `i`と`j`の深さが同じになるように一方の祖先をたどる。
2. `i`と`j`が一致する場合、これが最小共通祖先である。
3. `k in (0..=H.ilg2()).rev()`について、`A[i][k]`と`A[j][k]`が一致しない場合、`i`と`j`を更新する。
4. `P[i]`と`P[j]`が必ず一致し、これが最小共通祖先である。

したがって、ダブリングで最小共通祖先を求めることができる。計算量はクエリ当たり\\( \Theta(\log H) \\)である。

最小共通祖先を利用することで、以下の量を対数時間で求めることができる。`i`と`j`の最小共通祖先を`LCA(i, j)`とかくことにする。

### 最短パスの長さ

`i`と`j`を結ぶ最短パスは`i`・`LCA(i, j)`・`j`をこの順につなぐ単純パスの長さである。`i`の深さを`depth[i]`とかくと、その長さは`dist(i, j) = depth[i] + depth[j] - 2 * depth[LCA(i, j)]`で与えられる。

### パス上の重みの合成

頂点やパスに重み`W[i]`が設定されている場合を考える。半開区間`[i, A[i][k])`における重みを上から合成したものを`U[i][k]`、下から合成したものを`D[i][k]`とかく。これは`P[i]`のダブリングと並行して計算することができる。ダブリングにより`i`と祖先を結ぶ単純パス上で重みを合成することができる。

`i`から`j`に向かう単純パス上で重みを合成することもできる。`D[i..=LCA(i, j)] * U[i..LCA(i, j)]`である。

アフィン変換の合成など、可換でない場合も正しく動作する。

## 実装上の注意

木の構造を変更すると`A`が破綻してしまう。再計算には\\( \Theta(V \log H) \\)の時間がかかるため、immutableな木に限って考える。

### 初期化

初期化関数`new()`の引数として、少なくとも次の2つが考えられる。

親へのポインター`P`を引数として与える場合、ユーザーの責任で「根の親が根」であることを保証する必要がある。\\( (V - 1) \\)個の無向辺と根のインデックスを与える場合、根の親をどう定義するかという問題を隠ぺいできるが、計算コストが\\( \Theta(N) \\)だけ悪化する[^note-init2]。

また、与えられた辺[^note-init]が正しく木を構成しているか検証する必要がある。不正な頂点インデックスが使用されている場合、ダブリングの際に配列の範囲外アクセスでパニックする。（連結でない）グラフが与えられた場合、祖先をたどることはできるがLCAのアルゴリズムが破綻してしまう。したがって、バリデーションには何か追加の実装が必要である。もっとも簡単なのは、深さを求めるついでに訪問済み頂点の個数を数えておくことである。

時間・空間計算量ともに\\( \Theta(V \log H) \\)である。

[^note-init]: 親へのポインター`P`は有向辺である。
[^note-init2]: 1 msでも速くしたい場合に、考慮する価値がある。

### 深さの計算

ダブリングでも頂点の深さを求めることができるが、初期化の際に計算しておく方がよい。`A`を構築している以上、複数のLCAクエリに答える必要があると考えるのが自然だからである。

`new()`の引数として、上にあげた2つの方法のどちらを採用しても親から子への隣接リストを\\( \Theta(V) \\)で構築できる。根からDFSを行うことですべての頂点の深さを\\( \Theta(V) \\)で計算できる。この際に、訪問した頂点の個数が\\( V \\)であることを確認すると良い。

## 付録

3つ以上の頂点を結ぶ最小の部グラフ[^appendix-subgraph]に含まれる辺の数を求めることができる[^note-appendix]。頂点の数を\\( N \\)とおく。

1. 頂点をDFS帰りがけ順でソートする。帰りがけ順序は深さを求めるついでに計算できる。
2. `LCA(0, 1)`と`dist(0, 1)`を求めておく。
3. `i in 1..M - 1`について、`LCA(i, i + 1)`を計算する。差分計算の方法は2パターンしかない。

![Minimum subtree](min_subgraph.drawio.svg)

計算量は\\( O(N (\log H + \log N)) \\)である。

[^appendix-subgraph]: 木だが部分木ではない。
[^note-appendix]: 2つの頂点の場合は、単純パスを考えればよい。
