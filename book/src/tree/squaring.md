# ダブリング

\\(N\\)個のノードからなる根つき木を考える。すべての子はただ1つの親を持つので、`i`番目のノードの親を`P[i]`とかくことができる。ただし根の親を根と定義する。`P`は1次元配列なので、ダブリングにより高々対数時間で祖先をたどることができる。

## 最小共通祖先（LCA）

次のアルゴリズムにより、任意の2つのノード`i`と`j`ついて最小共通祖先を求めることができる。`i`の\\(2^k\\)番目の祖先を`A[i][k]`とかくことにする。また、木の高さを\\( H \\)とおく。

1. `i`と`j`の深さが同じになるように一方の祖先をたどる。
2. `i`と`j`が一致する場合、これが最小共通祖先である。
3. `k in (0..=H.ilg2()).rev()`について、`A[i][k]`と`A[j][k]`が一致しない場合、`i`と`j`を更新する。
4. `P[i]`と`P[j]`が必ず一致し、これが最小共通祖先である。

したがって、ダブリングで最小共通祖先を求めることができる。計算量はクエリ当たり\\( \Theta(\log H) \\)である。

最小共通祖先を利用することで、以下の量を対数時間で求めることができる。`i`と`j`の最小共通祖先を`LCA(i, j)`とかくことにする。

### 最短パスの長さ

`i`と`j`を結ぶ最短パスは`i`・`LCA(i, j)`・`j`をこの順につなぐ単純パスの長さである。`i`の深さを`depth[i]`とかくと、その長さは`depth[i] + depth[j] - 2 * depth[LCA(i, j)]`で与えられる。

### パス上の重みの合成

ノードやパスに重み`W[i]`が設定されている場合を考える。半開区間`[i, A[i][k])`における重みを上から合成したものを`U[i][k]`、下から合成したものを`D[i][k]`とかく。これは`P[i]`のダブリングと並行して計算することができる。ダブリングにより`i`と祖先を結ぶ単純パス上で重みを合成することができる。

`i`から`j`に向かう単純パス上で重みを合成することもできる。`D[i..=LCA(i, j)] * U[i..LCA(i, j)]`である。

アフィン変換の合成など、可換でない場合も正しく動作する。

## 実装上の注意

木の構造を変更すると`A`が破綻してしまう。再計算には\\( \Theta(N \log H) \\)の時間がかかるため、immutableな木に限って考える。

### 初期化

初期化関数`new()`の引数として、少なくとも次の2つが考えられる。

親へのポインター`P`を引数として与える場合、ユーザーの責任で「根の親が根」であることを保証する必要がある。\\( (N - 1) \\)個の無向辺と根のインデックスを与える場合、根の親をどう定義するかという問題を隠ぺいできるが、無向辺の処理に\\( \Theta(N) \\)の時間がかかってしまう。

また、与えられた辺[^note-init]が正しく木を構成しているか検証する必要がある。不正なノードインデックスが使用されている場合、ダブリングの際に配列の範囲外アクセスでパニックする。（連結でない）グラフが与えられた場合、祖先をたどることはできるがLCAのアルゴリズムが破綻してしまう。したがって、バリデーションには何か追加の実装が必要である。もっとも簡単なのは、深さを求めるついでに訪問済み頂点の個数を数えておくことである。

[^note-init]: 親へのポインター`P`は有向辺である。

### 深さの計算

ダブリングでもノードの深さを求めることができるが、初期化の際に計算しておく方がよい。`A`を構築している以上、複数のLCAクエリに答える必要があると考えるのが自然だからである。

`new()`の引数として、上にあげた2つの方法のどちらを採用しても親から子への隣接リストを\\( \Theta (N) \\)で構築できる。根からDFSを行うことですべてのノードの深さを\\( \Theta (N) \\)で計算できる。この際に、訪問した頂点の個数が\\( N \\)であることを確認すると良い。

## 付録：最小部分木

3つ以上のノードを結ぶ最小の部分木を求めることができる[^note-appendix]。ノードの数を\\( M \\)とおく。

1. ノードをDFS帰りがけ順でソートする。これは深さを求めるついでに計算できる。
2. TODO

[^note-appendix]: 2つのノードの場合は、単純パスを考えればよい。
