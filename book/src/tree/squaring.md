# ダブリング

\\(N\\)個のノードからなる木を考える。すべての子はただ1つの親を持つので、`i`番目のノードの親を`P[i]`とかくことができる。ただし根の親を根と定義する。`P`は1次元配列なので、ダブリングにより高々対数時間で祖先をたどることができる。

## 最小共通祖先（LCA）

次のアルゴリズムにより、任意の2つのノード`i`と`j`ついて最小共通祖先を求めることができる。`i`の\\(2^k\\)番目の祖先を`A[i][k]`とかくことにする。また、\\( K = \log_2(\mathrm{tree\ height}) \\)とおく。

1. `i`と`j`の深さが同じになるように一方の祖先をたどる。
2. `i`と`j`が一致する場合、これが最小共通祖先である。
3. `k = (0..=K).rev()`について、`A[i][k]`と`A[j][k]`が一致しない場合、`i`と`j`を更新する。
4. `P[i]`と`P[j]`が必ず一致し、これが最小共通祖先である。

したがって、ダブリングで最小共通祖先を求めることができる。計算量はクエリ当たり\\( O(\log N)\\)である。

最小共通祖先を利用することで、以下の量を対数時間で求めることができる。`i`と`j`の最小共通祖先を`LCA(i, j)`とかくことにする。

### 最短パスの長さ

`i`と`j`を結ぶ最短パスは`i`・`LCA(i, j)`・`j`をこの順につなぐ単純パスの長さである。`i`の深さを`depth[i]`とかくと、その長さは`depth[i] + depth[j] - 2 * depth[LCA(i, j)]`で与えられる。

### パス上の重みの合成

ノードに重み`W[i]`が設定されている場合を考える。半開区間`[i, A[i][k])`における重みを上から合成したものを`U[i][k]`、下から合成したものを`D[i][k]`とかく。これは`P[i]`のダブリングと並行して計算することができる。ダブリングにより`i`と祖先を結ぶ単純パス上で重みを合成することができる。

`i`から`j`に向かう単純パス上で重みを合成することもできる。`D[i..=LCA(i, j)] * U[i..LCA(i, j)]`である。

アフィン変換の合成など、可換でない場合も正しく動作する。

## 実装上の注意

TODO
